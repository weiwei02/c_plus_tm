
// https://leetcode.cn/problems/valid-sudoku/?envType=study-plan-v2&envId=top-interview-150
// 36. 有效的数独
// 中等
// 相关标签
// 相关企业
// 请你判断一个 9 x 9 的数独是否有效。只需要 根据以下规则 ，验证已经填入的数字是否有效即可。

// 数字 1-9 在每一行只能出现一次。
// 数字 1-9 在每一列只能出现一次。
// 数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。（请参考示例图）
 

// 注意：

// 一个有效的数独（部分已被填充）不一定是可解的。
// 只需要根据以上规则，验证已经填入的数字是否有效即可。
// 空白格用 '.' 表示。
 

// 示例 1：


// 输入：board = 
// [['5','3','.','.','7','.','.','.','.']
// ,['6','.','.','1','9','5','.','.','.']
// ,['.','9','8','.','.','.','.','6','.']
// ,['8','.','.','.','6','.','.','.','3']
// ,['4','.','.','8','.','3','.','.','1']
// ,['7','.','.','.','2','.','.','.','6']
// ,['.','6','.','.','.','.','2','8','.']
// ,['.','.','.','4','1','9','.','.','5']
// ,['.','.','.','.','8','.','.','7','9']]
// 输出：true
// 示例 2：

// 输入：board = 
// [['8','3','.','.','7','.','.','.','.']
// ,['6','.','.','1','9','5','.','.','.']
// ,['.','9','8','.','.','.','.','6','.']
// ,['8','.','.','.','6','.','.','.','3']
// ,['4','.','.','8','.','3','.','.','1']
// ,['7','.','.','.','2','.','.','.','6']
// ,['.','6','.','.','.','.','2','8','.']
// ,['.','.','.','4','1','9','.','.','5']
// ,['.','.','.','.','8','.','.','7','9']]
// 输出：false
// 解释：除了第一行的第一个数字从 5 改为 8 以外，空格内其他数字均与 示例1 相同。 但由于位于左上角的 3x3 宫内有两个 8 存在, 因此这个数独是无效的。
 

// 提示：

use std::collections::HashSet;

// board.length == 9
// board[i].length == 9
// board[i][j] 是一位数字（1-9）或者 '.'
#[cfg(test)]
mod tests {
    use super::Solution;
    #[test]
    fn test_total_n_queens() {
        assert_eq!(Solution::is_valid_sudoku(
            vec![
                vec!['5','3','.','.','7','.','.','.','.'],
                vec!['6','.','.','1','9','5','.','.','.'],
                vec!['.','9','8','.','.','.','.','6','.'],
                vec!['8','.','.','.','6','.','.','.','3'],
                vec!['4','.','.','8','.','3','.','.','1'],
                vec!['7','.','.','.','2','.','.','.','6'],
                vec!['.','6','.','.','.','.','2','8','.'],
                vec!['.','.','.','4','1','9','.','.','5'],
                vec!['.','.','.','.','8','.','.','7','9']
            ]
        ), true);
        assert_eq!(Solution::is_valid_sudoku(vec![
            vec!['8','3','.','.','7','.','.','.','.'],
            vec!['6','.','.','1','9','5','.','.','.'],
            vec!['.','.','9','8','.','.','.','6','.'],
            vec!['8','.','.','.','6','.','.','.','3'],
            vec!['4','.','.','8','.','3','.','.','1'],
            vec!['7','.','.','.','2','.','.','.','6'],
            vec!['.','.','6','.','.','.','2','8','.'],
            vec!['.','.','.','4','1','9','.','.','5'],
            vec!['.','.','.','.','8','.','.','7','9']
        ]), false);
    }
}

struct Solution;
impl Solution {
    // 思路
    // 更有效的搜索，使用hash表来加速搜索
    // 1. 遍历矩阵，为每一行，每一列都建立一个hash表，记录出现过的数字
    // 2. 遍历矩阵，为每一个九宫格建立hash表，记录出现过的数字
    // 2.1 九宫格的起始坐标时 i%3 = 0, 结束坐标是i%3=2，所以建立矩阵时 使用 i = 0..3, i*3 + 0..3  
    // 来收集九宫格元素，并把hash表存到 3*3的矩阵中
    // 3. 遍历矩阵，如果出现重复的数字，返回false
    // 3.1 判断坐标在哪个九宫格的办法 i * j / 9 
    pub fn is_valid_sudoku(board: Vec<Vec<char>>) -> bool {
        let m = board.len();
        let mut row_hash: Vec<HashSet<char>> = vec![HashSet::new(); m];
        let mut col_hash: Vec<HashSet<char>> = vec![HashSet::new(); m];
        let mut box_hash: Vec<Vec<HashSet<char>>>= vec![vec![HashSet::new(); m / 3]; m / 3];
        for i in 0..m {
            for j in 0..m {
                let c = board[i][j];
                if c != '.' {
                    if row_hash[i].contains(&c) || col_hash[j].contains(&c) || box_hash[i / 3][j / 3].contains(&c) {
                        return false;
                    }

                    row_hash[i].insert(c);
                    col_hash[j].insert(c);
                    box_hash[i / 3][j / 3].insert(c);
                }
            }
        }
        
        true
    }
}