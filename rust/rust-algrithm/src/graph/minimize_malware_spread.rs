// https://leetcode.cn/problems/minimize-malware-spread/description/?envType=daily-question&envId=2024-04-16
// 924. 尽量减少恶意软件的传播 困难
// 给出了一个由 n 个节点组成的网络，用 n × n 个邻接矩阵图 graph 表示。在节点网络中，当 graph[i][j] = 1 时，
// 表示节点 i 能够直接连接到另一个节点 j。
// 一些节点 initial 最初被恶意软件感染。只要两个节点直接连接，且其中至少一个节点受到恶意软件的感染，
// 那么两个节点都将被恶意软件感染。这种恶意软件的传播将继续，直到没有更多的节点可以被这种方式感染。
// 假设 M(initial) 是在恶意软件停止传播之后，整个网络中感染恶意软件的最终节点数。
// 如果从 initial 中移除某一节点能够最小化 M(initial)， 返回该节点。如果有多个节点满足条件，就返回索引最小的节点。
// 请注意，如果某个节点已从受感染节点的列表 initial 中删除，它以后仍有可能因恶意软件传播而受到感染。

// 示例 1：
// 输入：graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1]
// 输出：0

// 示例 2：
// 输入：graph = [[1,0,0],[0,1,0],[0,0,1]], initial = [0,2]
// 输出：0

// 示例 3：
// 输入：graph = [[1,1,1],[1,1,1],[1,1,1]], initial = [1,2]
// 输出：1

// 提示：
// n == graph.length
// n == graph[i].length
// 2 <= n <= 300
// graph[i][j] == 0 或 1.
// graph[i][j] == graph[j][i]
// graph[i][i] == 1
// 1 <= initial.length <= n
// 0 <= initial[i] <= n - 1
// initial 中所有整数均不重复

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_re_match() {
        assert_eq!(
            Solution::min_malware_spread(
                vec![vec![1,1,0],vec![1,1,0],vec![0,0,1],],
                vec![0, 1,2]
            ),
            2
        );
        assert_eq!(
            Solution::min_malware_spread(
                vec![vec![1, 1, 0], vec![1, 1, 0], vec![0, 0, 1],],
                vec![0, 1]
            ),
            0
        );
        assert_eq!(
            Solution::min_malware_spread(
                vec![vec![1, 0, 0], vec![0, 1, 0], vec![0, 0, 1],],
                vec![0, 2]
            ),
            0
        );
        assert_eq!(
            Solution::min_malware_spread(
                vec![vec![1, 1, 1], vec![1, 1, 1], vec![1, 1, 1],],
                vec![1, 2]
            ),
            1
        );
    }
}

struct Solution;
impl Solution {
    // 思路： 从 initial 中移除某一节点能够最小化 M(initial)
    // 1. 以intial 节点为key，记录所有感染的节点，value 为直接相连的节点列表
    // 2. 遍历感染的节点列表，找到在graph中感染的节点，并记录感染的节点直接相连的感染的节点
    // 3. 遍历感染的节点列表，找到感染map中直接相连节点数最大的感染节点
    pub fn min_malware_spread(graph: Vec<Vec<i32>>, initial: Vec<i32>) -> i32 {
        let mut initial = initial.clone();
        initial.sort();
        let mut infected_map: std::collections::HashMap<i32, Vec<usize>> =
            std::collections::HashMap::from_iter(initial.iter().map(|&i| (i, vec![])));
        let mut no_infected_map: std::collections::HashMap<i32, Vec<usize>> = infected_map.clone();
        
        initial.iter().for_each(|&i| {
            let col = i as usize;
            let conn = graph
                .iter()
                .enumerate()
                // .filter(|&(j, _)| !infected_map.contains_key(&(j as i32)))
                .filter(|&(j, _)| j != row)
                .filter(|(j, row)| row[col] == 1)
                .map(|(j, _)| j)
                .collect::<Vec<usize>>();
            infected_map.insert(col as i32, conn);
        });

        println!("infected_map: {:?}", infected_map);
        let mut max_index = initial[0];
        initial.iter().skip(0).for_each(|i| {
            if infected_map.get(i).unwrap().len() > infected_map.get(&max_index).unwrap().len() {
                max_index = *i;
            }
        });
        max_index
    }
}
